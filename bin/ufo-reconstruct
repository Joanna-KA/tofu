#!/usr/bin/env python

import os
import sys
import re
import argparse
import numpy as np
from gi.repository import Ufo


def is_format_specifier(path):
    return re.search(r"%[0-9]+i", path)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--axis', type=float, default=1000.0,
                        help="Axis position")
    parser.add_argument('-s', '--angle-step', type=float, default=None,
                        help="Angle step between projections")
    parser.add_argument('-o', '--output', type=str, default='.', metavar='PATH',
                        help="Path to location or format-specified file path"
                             "for storing reconstructed slices")
    parser.add_argument('-i', '--input', type=str, default='.', metavar='PATH',
                        help="Location with sinograms")
    
    parser.add_argument('--method', choices=['fbp', 'sart', 'dfi'], default='fbp')
    parser.add_argument('--first-slice', type=int, default=None, metavar='N',
                        help="First slice")
    parser.add_argument('--last-slice', type=int, default=None, metavar='N',
                        help="Last slice")
    parser.add_argument('--include', type=str, nargs='*', default=None, metavar='PATH',
                        help="Paths to search for plugins and kernel files")
    parser.add_argument('--server', type=str, nargs='*', default=[], metavar='ADDR',
                        help="ZeroMQ addresses of machines on which `ufod' is running")

    args = parser.parse_args()
    cargs = {}

    if args.include:
        config = Ufo.Config(paths=args.include)
        cargs['config'] = config

    # Create reader and writer
    pm = Ufo.PluginManager(**cargs)
    reader = pm.get_task('reader')
    writer = pm.get_task('writer')

    # Configure reader and writer
    reader.props.path = args.input

    if args.first_slice:
        reader.props.nth = args.first_slice

        if args.last_slice:
            reader.props.count = args.last_slice - args.first_slice

    abs_path = os.path.abspath(args.output)

    if is_format_specifier(args.output):
        outname = abs_path
    else:
        outname = os.path.join(abs_path, 'slice-%05i.tif')

    writer.set_properties(filename=outname)

    # Setup graph depending on the chosen method
    g = Ufo.TaskGraph()

    def get_task(name, **kwargs):
        task = pm.get_task(name)
        task.set_properties(**kwargs)
        return task

    if args.method == 'fbp':
        fft = pm.get_task('fft')
        ifft = pm.get_task('ifft')
        fltr = pm.get_task('filter')
        bp = pm.get_task('backproject')

        fft.props.dimensions = 1
        ifft.props.dimensions = 1
        bp.props.axis_pos = args.axis

        if args.angle_step:
            bp.props.angle_step = args.angle_step

        g.connect_nodes(reader, fft)
        g.connect_nodes(fft, fltr)
        g.connect_nodes(fltr, ifft)
        g.connect_nodes(ifft, bp)
        g.connect_nodes(bp, writer)

    if args.method == 'sart':
        art = pm.get_task('art')
        art.set_properties(method='sart',
                           projector='joseph',
                           regularizer='tv',
                           angle_step=args.angle_step,
                           max_iterations=5,
                           max_regularizer_iterations=20,
                           posc=False)

        g.connect_nodes(reader, art)
        g.connect_nodes(art, writer)

    if args.method == 'dfi':
        cut = get_task('cut-sinogram', center_of_rotation=args.axis)
        pad = get_task('zeropadding', oversampling=1)
        fft = get_task('fft', dimensions=1, auto_zeropadding=0)
        dfi = get_task('dfi-sinc')
        ifft = get_task('ifft', dimensions=2)
        swap_forward = get_task('swap-quadrants')
        swap_backward = get_task('swap-quadrants')

        g.connect_nodes(reader, cut)
        g.connect_nodes(cut, pad)
        g.connect_nodes(pad, fft)
        g.connect_nodes(fft, dfi)
        g.connect_nodes(dfi, swap_forward)
        g.connect_nodes(swap_forward, ifft)
        g.connect_nodes(ifft, swap_backward)
        g.connect_nodes(swap_backward, writer)


    sched = Ufo.Scheduler()
    sched.run(g)


# vim: ft=python
